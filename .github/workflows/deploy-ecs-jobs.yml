name: Deploy ECS Jobs

on:
  push:
    branches:
      - master  # Changed from main
    paths:
      - 'jobs/**'
      - 'app/db/**'
      - 'app/services/**'
      - 'app/config.py'
      - 'app/models/**'
      - 'app/collectors/**'
      - 'ingest/**'
      - 'infrastructure/terraform/**'
      - '.github/workflows/deploy-ecs-jobs.yml'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging
      dry_run:
        description: 'Dry run mode (build/plan only, no push/apply)'
        required: false
        default: false
        type: boolean

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: market-pulse-jobs

jobs:
  build-and-deploy:
    name: Build and Deploy to ECS
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2  # Need 2 commits to detect changes

      - name: Detect changes
        id: changes
        run: |
          echo "Detecting which paths changed..."
          
          # For workflow_dispatch, check all files
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "terraform_changed=true" >> $GITHUB_OUTPUT
            echo "jobs_changed=true" >> $GITHUB_OUTPUT
            echo "Manual trigger - will check both terraform and jobs"
            exit 0
          fi
          
          # Get list of changed files
          CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD)
          echo "Changed files:"
          echo "$CHANGED_FILES"
          
          # Check if workflow file itself changed
          WORKFLOW_CHANGED=false
          if echo "$CHANGED_FILES" | grep -q "^\.github/workflows/deploy-ecs-jobs\.yml"; then
            WORKFLOW_CHANGED=true
            echo "‚úÖ Workflow file changed - will trigger full pipeline"
          fi
          
          # Check if terraform files changed
          if echo "$CHANGED_FILES" | grep -q "^infrastructure/terraform/"; then
            echo "terraform_changed=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Terraform files changed"
          elif [ "$WORKFLOW_CHANGED" = "true" ]; then
            # If workflow changed, also check terraform (for safety)
            echo "terraform_changed=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Terraform check triggered due to workflow change"
          else
            echo "terraform_changed=false" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è  No terraform changes"
          fi
          
          # Check if job/app files changed
          if echo "$CHANGED_FILES" | grep -qE "^(jobs/|app/|ingest/)"; then
            echo "jobs_changed=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Job/app files changed"
          elif [ "$WORKFLOW_CHANGED" = "true" ]; then
            # If workflow changed, also check jobs (for safety)
            echo "jobs_changed=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Jobs check triggered due to workflow change"
          else
            echo "jobs_changed=false" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è  No job/app changes"
          fi

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      # ============================================================================
      # DOCKER BUILD & PUSH WORKFLOW
      # ============================================================================

      - name: Login to Amazon ECR
        id: login-ecr
        if: steps.changes.outputs.jobs_changed == 'true'
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up Docker Buildx
        if: steps.changes.outputs.jobs_changed == 'true'
        uses: docker/setup-buildx-action@v3

      - name: Build, tag, and push image to Amazon ECR
        id: build-image
        if: steps.changes.outputs.jobs_changed == 'true'
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
          DRY_RUN: ${{ github.event.inputs.dry_run || 'false' }}
        run: |
          echo "Building Docker image..."
          docker build -f jobs/Dockerfile -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          
          # Get image size and digest for logging
          IMAGE_SIZE=$(docker image inspect $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG --format='{{.Size}}' | awk '{printf "%.2f MB", $1/1024/1024}')
          echo "Image size: $IMAGE_SIZE"
          
          if [ "$DRY_RUN" = "true" ]; then
            echo "üîç DRY RUN MODE - Skipping push to ECR"
            echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT
            echo "image_size=$IMAGE_SIZE" >> $GITHUB_OUTPUT
            echo "pushed=false" >> $GITHUB_OUTPUT
          else
            echo "Pushing image to ECR..."
            docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
            docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
            docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
            
            # Get image digest from ECR
            IMAGE_DIGEST=$(docker image inspect $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG --format='{{index .RepoDigests 0}}')
            
            echo "‚úÖ Successfully pushed image to ECR"
            echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT
            echo "image_size=$IMAGE_SIZE" >> $GITHUB_OUTPUT
            echo "image_digest=$IMAGE_DIGEST" >> $GITHUB_OUTPUT
            echo "pushed=true" >> $GITHUB_OUTPUT
          fi

      - name: Verify ECR image
        if: steps.changes.outputs.jobs_changed == 'true' && steps.build-image.outputs.pushed == 'true'
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          echo "Verifying images in ECR..."
          
          # Pull the specific tag to verify it exists
          docker pull $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          echo "‚úÖ Successfully pulled $IMAGE_TAG"
          
          # Pull latest tag to verify it was updated
          docker pull $ECR_REGISTRY/$ECR_REPOSITORY:latest
          echo "‚úÖ Successfully pulled latest tag"
          
          # Verify image digests match
          DIGEST_TAG=$(docker image inspect $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG --format='{{index .RepoDigests 0}}')
          DIGEST_LATEST=$(docker image inspect $ECR_REGISTRY/$ECR_REPOSITORY:latest --format='{{index .RepoDigests 0}}')
          
          if [ "$DIGEST_TAG" = "$DIGEST_LATEST" ]; then
            echo "‚úÖ Image digests match - latest tag correctly updated"
          else
            echo "‚ö†Ô∏è  Warning: Image digests don't match"
            echo "Tag digest: $DIGEST_TAG"
            echo "Latest digest: $DIGEST_LATEST"
          fi

      - name: Update ECS task definitions
        if: steps.changes.outputs.jobs_changed == 'true' && steps.build-image.outputs.pushed == 'true'
        id: update-tasks
        env:
          IMAGE_URI: ${{ steps.build-image.outputs.image }}
        run: |
          echo "Updating ECS task definitions with new image..."
          UPDATED_TASKS=""
          SKIPPED_TASKS=""
          HAS_FAILURES=0
          
          # Helper function to update a task definition if it exists
          update_task_definition() {
            local TASK_NAME=$1
            local TASK_FILE=$2
            
            echo "Checking $TASK_NAME..."
            
            # Check if task definition exists
            if aws ecs describe-task-definition \
              --task-definition "$TASK_NAME" \
              --query taskDefinition > "$TASK_FILE.json" 2>/dev/null; then
              
              echo "Updating $TASK_NAME..."
              jq --arg IMAGE "$IMAGE_URI" \
                '.containerDefinitions[0].image = $IMAGE | del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)' \
                "$TASK_FILE.json" > "$TASK_FILE-updated.json"

              # Registration failures are real errors and should fail the workflow
              if aws ecs register-task-definition \
                --cli-input-json file://"$TASK_FILE-updated.json" > /dev/null; then
                echo "‚úÖ Successfully updated $TASK_NAME"
                UPDATED_TASKS="$UPDATED_TASKS\n- $TASK_NAME"
                return 0
              else
                echo "‚ùå Failed to register updated task definition for $TASK_NAME"
                echo "This indicates a real deployment error (IAM permissions, validation, etc.)"
                return 1  # Registration failure - should fail workflow
              fi
            else
              echo "‚ÑπÔ∏è  Task definition $TASK_NAME does not exist yet (will be created by Terraform)"
              SKIPPED_TASKS="$SKIPPED_TASKS\n- $TASK_NAME (does not exist)"
              return 0  # Missing tasks are OK, continue
            fi
          }
          
          # Update all task definitions
          # Only suppress errors for tasks that don't exist (return 0)
          # Registration failures (return 1) should fail the workflow
          update_task_definition "market-pulse-reddit-scraper" "task-def-reddit" || {
            if [ $? -eq 1 ]; then HAS_FAILURES=1; fi
          }
          update_task_definition "market-pulse-sentiment-analysis" "task-def-sentiment" || {
            if [ $? -eq 1 ]; then HAS_FAILURES=1; fi
          }
          update_task_definition "market-pulse-daily-status" "task-def-status" || {
            if [ $? -eq 1 ]; then HAS_FAILURES=1; fi
          }
          update_task_definition "market-pulse-stock-price-collector" "task-def-stock-price" || {
            if [ $? -eq 1 ]; then HAS_FAILURES=1; fi
          }
          update_task_definition "market-pulse-send-daily-emails" "task-def-send-emails" || {
            if [ $? -eq 1 ]; then HAS_FAILURES=1; fi
          }
          update_task_definition "market-pulse-historical-backfill" "task-def-historical-backfill" || {
            if [ $? -eq 1 ]; then HAS_FAILURES=1; fi
          }
          
          # Fail the workflow if any registration failed
          if [ $HAS_FAILURES -eq 1 ]; then
            echo ""
            echo "‚ùå One or more task definition registrations failed."
            echo "This indicates a real deployment error (IAM permissions, validation, etc.) that must be fixed."
            exit 1
          fi
          
          echo ""
          if [ -n "$UPDATED_TASKS" ]; then
            echo "‚úÖ Updated task definitions:"
            echo -e "$UPDATED_TASKS"
          fi
          
          if [ -n "$SKIPPED_TASKS" ]; then
            echo ""
            echo "‚ÑπÔ∏è  Skipped task definitions:"
            echo -e "$SKIPPED_TASKS"
          fi
          echo "updated_tasks<<EOF" >> $GITHUB_OUTPUT
          if [ -n "$UPDATED_TASKS" ]; then
            echo -e "$UPDATED_TASKS" >> $GITHUB_OUTPUT
          else
            echo "- (none)" >> $GITHUB_OUTPUT
          fi
          echo "EOF" >> $GITHUB_OUTPUT
          
          echo "skipped_tasks<<EOF" >> $GITHUB_OUTPUT
          if [ -n "$SKIPPED_TASKS" ]; then
            echo -e "$SKIPPED_TASKS" >> $GITHUB_OUTPUT
          else
            echo "- (none)" >> $GITHUB_OUTPUT
          fi
          echo "EOF" >> $GITHUB_OUTPUT

      # ============================================================================
      # TERRAFORM WORKFLOW
      # ============================================================================

      - name: Setup Terraform
        if: steps.changes.outputs.terraform_changed == 'true'
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.6.0"

      - name: Terraform Init
        if: steps.changes.outputs.terraform_changed == 'true'
        working-directory: infrastructure/terraform
        run: |
          echo "Initializing Terraform..."
          terraform init

      - name: Import Existing Resources
        if: steps.changes.outputs.terraform_changed == 'true'
        working-directory: infrastructure/terraform
        env:
          TF_VAR_vpc_id: ${{ secrets.TF_VAR_VPC_ID }}
          TF_VAR_private_subnet_ids: ${{ secrets.TF_VAR_PRIVATE_SUBNET_IDS }}
          TF_VAR_postgres_security_group_id: ${{ secrets.TF_VAR_POSTGRES_SECURITY_GROUP_ID }}
        run: |
          echo "Attempting to import existing resources into Terraform state..."
          
          # Function to safely import a resource
          import_resource() {
            local resource_type=$1
            local resource_name=$2
            local resource_id=$3
            
            echo "Checking if $resource_name needs import..."
            
            # Check if resource already in state
            if terraform state show "$resource_type.$resource_name" &>/dev/null; then
              echo "‚úÖ $resource_name already in state, skipping import"
              return 0
            fi
            
            # Try to import
            if terraform import "$resource_type.$resource_name" "$resource_id" 2>&1 | tee -a import.log; then
              echo "‚úÖ Successfully imported $resource_name"
              return 0
            else
              # Check if error is because resource doesn't exist (we'll create it)
              if grep -q "does not exist\|not found" import.log; then
                echo "‚ÑπÔ∏è  $resource_name doesn't exist, will be created"
                return 0
              elif grep -q "already managed\|already imported" import.log; then
                echo "‚úÖ $resource_name already managed by Terraform"
                return 0
              else
                echo "‚ö†Ô∏è  Failed to import $resource_name (will try to create)"
                return 0  # Continue anyway
              fi
            fi
          }
          
          # Get AWS account ID and region for resource IDs
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          REGION="${AWS_REGION:-us-east-1}"
          PROJECT_NAME="market-pulse"
          
          # Import ECR repository
          import_resource "aws_ecr_repository" "jobs" "$PROJECT_NAME-jobs" || true
          
          # Import ECS cluster
          import_resource "aws_ecs_cluster" "jobs" "$PROJECT_NAME-jobs" || true
          
          # Import security group (need to find it first)
          SG_ID=$(aws ec2 describe-security-groups \
            --filters "Name=group-name,Values=$PROJECT_NAME-ecs-tasks" "Name=vpc-id,Values=${{ secrets.TF_VAR_VPC_ID }}" \
            --query 'SecurityGroups[0].GroupId' --output text 2>/dev/null || echo "")
          if [ -n "$SG_ID" ] && [ "$SG_ID" != "None" ]; then
            import_resource "aws_security_group" "ecs_tasks" "$SG_ID" || true
          fi
          
          # Import CloudWatch log groups
          import_resource "aws_cloudwatch_log_group" "reddit_scraper" "/ecs/$PROJECT_NAME-jobs/reddit-scraper" || true
          import_resource "aws_cloudwatch_log_group" "sentiment_analysis" "/ecs/$PROJECT_NAME-jobs/sentiment-analysis" || true
          import_resource "aws_cloudwatch_log_group" "daily_status" "/ecs/$PROJECT_NAME-jobs/daily-status" || true
          import_resource "aws_cloudwatch_log_group" "stock_price_collector" "/ecs/$PROJECT_NAME-jobs/stock-price-collector" || true
          import_resource "aws_cloudwatch_log_group" "send_daily_emails" "/ecs/$PROJECT_NAME-jobs/send-daily-emails" || true
          import_resource "aws_cloudwatch_log_group" "historical_backfill" "/ecs/$PROJECT_NAME-jobs/historical-backfill" || true
          
          # Import IAM roles
          import_resource "aws_iam_role" "ecs_task_execution" "$PROJECT_NAME-ecs-task-execution" || true
          import_resource "aws_iam_role" "ecs_task" "$PROJECT_NAME-ecs-task" || true
          import_resource "aws_iam_role" "eventbridge_scheduler" "$PROJECT_NAME-eventbridge-scheduler" || true
          import_resource "aws_iam_role" "eventbridge_ecs" "$PROJECT_NAME-eventbridge-ecs" || true
          
          # Import security group rule (if security group exists)
          if [ -n "$SG_ID" ] && [ "$SG_ID" != "None" ]; then
            # Security group rule format: sg-xxx_ingress_tcp_5432_5432_sg-yyy
            POSTGRES_SG_ID="${{ secrets.TF_VAR_POSTGRES_SECURITY_GROUP_ID }}"
            RULE_ID="${POSTGRES_SG_ID}_ingress_tcp_5432_5432_${SG_ID}"
            import_resource "aws_security_group_rule" "ecs_to_postgres" "$RULE_ID" || true
          fi
          
          # Import EventBridge Scheduler schedules
          import_resource "aws_scheduler_schedule" "reddit_scraper" "default/$PROJECT_NAME-reddit-scraper" || true
          import_resource "aws_scheduler_schedule" "sentiment_analysis" "default/$PROJECT_NAME-sentiment-analysis" || true
          import_resource "aws_scheduler_schedule" "daily_status" "default/$PROJECT_NAME-daily-status" || true
          import_resource "aws_scheduler_schedule" "stock_price_collector" "default/$PROJECT_NAME-stock-price-collector" || true
          import_resource "aws_scheduler_schedule" "send_daily_emails" "default/$PROJECT_NAME-send-daily-emails" || true
          
          echo "Import step completed. Continuing with plan..."

      - name: Terraform Plan
        if: steps.changes.outputs.terraform_changed == 'true'
        id: terraform-plan
        working-directory: infrastructure/terraform
        env:
          TF_VAR_vpc_id: ${{ secrets.TF_VAR_VPC_ID }}
          TF_VAR_private_subnet_ids: ${{ secrets.TF_VAR_PRIVATE_SUBNET_IDS }}
          TF_VAR_postgres_security_group_id: ${{ secrets.TF_VAR_POSTGRES_SECURITY_GROUP_ID }}
        run: |
          echo "Running Terraform plan..."
          terraform plan -out=tfplan -no-color | tee plan-output.txt
          
          # Save plan summary for later
          grep -A 100 "Terraform will perform" plan-output.txt > plan-summary.txt || echo "No changes detected" > plan-summary.txt
          
          echo "plan_file=tfplan" >> $GITHUB_OUTPUT

      - name: Terraform Apply
        if: steps.changes.outputs.terraform_changed == 'true' && github.event.inputs.dry_run != 'true'
        id: terraform-apply
        working-directory: infrastructure/terraform
        env:
          TF_VAR_vpc_id: ${{ secrets.TF_VAR_VPC_ID }}
          TF_VAR_private_subnet_ids: ${{ secrets.TF_VAR_PRIVATE_SUBNET_IDS }}
          TF_VAR_postgres_security_group_id: ${{ secrets.TF_VAR_POSTGRES_SECURITY_GROUP_ID }}
        run: |
          echo "Applying Terraform changes..."
          terraform apply -auto-approve tfplan
          echo "applied=true" >> $GITHUB_OUTPUT

      - name: Upload Terraform Plan
        if: steps.changes.outputs.terraform_changed == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: terraform-plan
          path: infrastructure/terraform/plan-summary.txt

      # ============================================================================
      # DEPLOYMENT SUMMARY
      # ============================================================================

      - name: Generate Deployment Summary
        if: always()
        env:
          JOBS_CHANGED: ${{ steps.changes.outputs.jobs_changed }}
          TERRAFORM_CHANGED: ${{ steps.changes.outputs.terraform_changed }}
          IMAGE_URI: ${{ steps.build-image.outputs.image }}
          IMAGE_SIZE: ${{ steps.build-image.outputs.image_size }}
          IMAGE_DIGEST: ${{ steps.build-image.outputs.image_digest }}
          IMAGE_PUSHED: ${{ steps.build-image.outputs.pushed }}
          UPDATED_TASKS: ${{ steps.update-tasks.outputs.updated_tasks }}
          TERRAFORM_APPLIED: ${{ steps.terraform-apply.outputs.applied }}
          DRY_RUN: ${{ github.event.inputs.dry_run || 'false' }}
        run: |
          echo "# üöÄ ECS Jobs Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "$DRY_RUN" = "true" ]; then
            echo "## üîç DRY RUN MODE" >> $GITHUB_STEP_SUMMARY
            echo "This was a dry run - no changes were pushed or applied." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "## üì¶ Docker Image Build" >> $GITHUB_STEP_SUMMARY
          if [ "$JOBS_CHANGED" = "true" ]; then
            echo "‚úÖ **Status**: Built" >> $GITHUB_STEP_SUMMARY
            if [ "$IMAGE_PUSHED" = "true" ]; then
              echo "‚úÖ **Pushed to ECR**: Yes" >> $GITHUB_STEP_SUMMARY
              echo "- **Image URI**: \`$IMAGE_URI\`" >> $GITHUB_STEP_SUMMARY
              echo "- **Image Size**: $IMAGE_SIZE" >> $GITHUB_STEP_SUMMARY
              echo "- **Image Digest**: \`$IMAGE_DIGEST\`" >> $GITHUB_STEP_SUMMARY
              echo "- **[View in AWS Console](https://console.aws.amazon.com/ecr/repositories/private/${{ env.AWS_REGION }}/${{ env.ECR_REPOSITORY }}?region=${{ env.AWS_REGION }})**" >> $GITHUB_STEP_SUMMARY
            else
              echo "‚è≠Ô∏è **Pushed to ECR**: Skipped (dry run)" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "‚è≠Ô∏è **Status**: Skipped (no job/app changes detected)" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "## üîÑ ECS Task Definitions Updated" >> $GITHUB_STEP_SUMMARY
          if [ "$JOBS_CHANGED" = "true" ] && [ "$IMAGE_PUSHED" = "true" ]; then
            UPDATED_TASKS_VALUE="${{ steps.update-tasks.outputs.updated_tasks }}"
            SKIPPED_TASKS_VALUE="${{ steps.update-tasks.outputs.skipped_tasks }}"
            
            if [ -n "$UPDATED_TASKS_VALUE" ] && [ "$UPDATED_TASKS_VALUE" != "- (none)" ]; then
              echo "**Updated:**" >> $GITHUB_STEP_SUMMARY
              echo "$UPDATED_TASKS_VALUE" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
            fi
            
            if [ -n "$SKIPPED_TASKS_VALUE" ] && [ "$SKIPPED_TASKS_VALUE" != "- (none)" ]; then
              echo "**Skipped (will be created by Terraform):**" >> $GITHUB_STEP_SUMMARY
              echo "$SKIPPED_TASKS_VALUE" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
            fi
            
            echo "**View Logs**:" >> $GITHUB_STEP_SUMMARY
            echo "- [Reddit Scraper Logs](https://console.aws.amazon.com/cloudwatch/home?region=${{ env.AWS_REGION }}#logsV2:log-groups/log-group/\$252Fecs\$252Fmarket-pulse-jobs\$252Freddit-scraper)" >> $GITHUB_STEP_SUMMARY
            echo "- [Sentiment Analysis Logs](https://console.aws.amazon.com/cloudwatch/home?region=${{ env.AWS_REGION }}#logsV2:log-groups/log-group/\$252Fecs\$252Fmarket-pulse-jobs\$252Fsentiment-analysis)" >> $GITHUB_STEP_SUMMARY
            echo "- [Daily Status Logs](https://console.aws.amazon.com/cloudwatch/home?region=${{ env.AWS_REGION }}#logsV2:log-groups/log-group/\$252Fecs\$252Fmarket-pulse-jobs\$252Fdaily-status)" >> $GITHUB_STEP_SUMMARY
            echo "- [Stock Price Collector Logs](https://console.aws.amazon.com/cloudwatch/home?region=${{ env.AWS_REGION }}#logsV2:log-groups/log-group/\$252Fecs\$252Fmarket-pulse-jobs\$252Fstock-price-collector)" >> $GITHUB_STEP_SUMMARY
            echo "- [Send Daily Emails Logs](https://console.aws.amazon.com/cloudwatch/home?region=${{ env.AWS_REGION }}#logsV2:log-groups/log-group/\$252Fecs\$252Fmarket-pulse-jobs\$252Fsend-daily-emails)" >> $GITHUB_STEP_SUMMARY
            echo "- [Historical Backfill Logs](https://console.aws.amazon.com/cloudwatch/home?region=${{ env.AWS_REGION }}#logsV2:log-groups/log-group/\$252Fecs\$252Fmarket-pulse-jobs\$252Fhistorical-backfill)" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚è≠Ô∏è Skipped" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "## üèóÔ∏è Terraform Infrastructure" >> $GITHUB_STEP_SUMMARY
          if [ "$TERRAFORM_CHANGED" = "true" ]; then
            if [ "$TERRAFORM_APPLIED" = "true" ]; then
              echo "‚úÖ **Status**: Applied" >> $GITHUB_STEP_SUMMARY
            elif [ "$DRY_RUN" = "true" ]; then
              echo "‚úÖ **Status**: Planned (dry run, not applied)" >> $GITHUB_STEP_SUMMARY
            else
              echo "‚úÖ **Status**: Planned" >> $GITHUB_STEP_SUMMARY
            fi
            echo "- See [Terraform Plan artifact](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}) for details" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚è≠Ô∏è **Status**: Skipped (no terraform changes detected)" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "## üìä Deployment Info" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit**: \`${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch**: \`${{ github.ref_name }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Region**: ${{ env.AWS_REGION }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Triggered by**: ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "$JOBS_CHANGED" = "true" ] && [ "$IMAGE_PUSHED" = "true" ]; then
            echo "## üß™ Next Steps" >> $GITHUB_STEP_SUMMARY
            echo "To verify the deployment:" >> $GITHUB_STEP_SUMMARY
            echo '```bash' >> $GITHUB_STEP_SUMMARY
            echo "# Manually trigger a task to test the new image" >> $GITHUB_STEP_SUMMARY
            echo "make ecs-run-stock-prices" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "# Watch the logs" >> $GITHUB_STEP_SUMMARY
            echo "make ecs-logs-stock-prices" >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
          fi

      - name: Final Status
        if: always()
        run: |
          echo "============================================"
          echo "         üéâ Deployment Pipeline Complete"
          echo "============================================"
          echo ""
          if [ "${{ steps.changes.outputs.jobs_changed }}" = "true" ]; then
            echo "‚úÖ Docker: Built and pushed"
          fi
          if [ "${{ steps.changes.outputs.terraform_changed }}" = "true" ]; then
            echo "‚úÖ Terraform: Planned and applied"
          fi
          if [ "${{ steps.changes.outputs.jobs_changed }}" = "false" ] && [ "${{ steps.changes.outputs.terraform_changed }}" = "false" ]; then
            echo "‚ÑπÔ∏è  No changes detected in monitored paths"
          fi
          echo ""
          echo "See the summary tab for full deployment details"
