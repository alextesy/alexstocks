# AWS Lambda & Serverless Opportunities

## Current Compute Footprint
- Batch workloads (Reddit scraper, sentiment analyzer, and daily status) share the `jobs/` runtime and run on ECS Fargate Spot with EventBridge Scheduler triggers, so every task currently bootstraps a full container image that copies the `app/` + `ingest/` trees before doing a short burst of work.【F:README.md†L63-L125】【F:jobs/README.md†L7-L175】
- The long-range migration guide already references a `refactor/create-lambdas` branch, which means serverless entry points are expected to co-exist with the Fargate fleet once the infrastructure pipeline can deploy them consistently.【F:docs/COMPLETE_MIGRATION_PLAN.md†L1-L80】

## Lambda-Friendly Workloads to Prioritize
| Workload | Current entry point(s) | Why Lambda could help | AWS services & tools to consider |
| --- | --- | --- | --- |
| Daily Slack summary + summary persistence | `jobs/jobs/daily_status.py` orchestrates LangChain output, Slack notifications, and `DailyTickerSummary` upserts before exiting.【F:jobs/jobs/daily_status.py†L50-L219】 | Runs once per day, spends most of its time in I/O (LLM call, Postgres writes, Slack webhook). Lambda + EventBridge Scheduler would remove a dedicated ECS task definition while still allowing Step Functions retries for the Slack + DB phases. | *EventBridge Scheduler* (cron trigger), *Step Functions Express* (parallel Slack + DB states), *Lambda Powertools* (logging/metrics), *Secrets Manager* (DB + Slack tokens), *RDS Data API* for short-lived writes so the function never opens a direct TCP connection. |
| Daily briefing email previewer | `app/scripts/send_daily_briefing_email.py` collects a user’s watchlist and renders the SES template for a single test inbox, aborting quickly once SES responds.【F:app/scripts/send_daily_briefing_email.py†L1-L126】 | Single-recipient preview is an ideal “ephemeral control plane” task. Converting it into a Lambda invoked via EventBridge (or a manual API Gateway button) avoids maintaining EC2/systemd timers when you only need ad-hoc emails, and SES already integrates natively with Lambda for error callbacks. | *Lambda + SES Invocation* (synchronous send), *AppConfig* or *Parameter Store* for toggling template variants, *CloudWatch Evidently* to A/B copy, *SNS* for failure fan-out. |
| Stock price deltas + notifications | `jobs/jobs/stock_price_collector.py` and the shared collector service hydrate top tickers every 15 minutes, then fan results to Slack via `run_with_slack_async`.【F:jobs/jobs/stock_price_collector.py†L1-L120】【F:app/collectors/stock_price_collector.py†L1-L117】 | The collection already batches API calls and writes summaries to `StockDataCollection`, so you can split the run into: (1) Lambda that queries Aurora and builds a “top symbols” payload, (2) Lambda that fetches Yahoo Finance batches, and (3) Lambda that publishes deltas to Slack/SNS. Each chunk is <15 minutes, and Lambda provisioned concurrency during market hours keeps p95 latency low without always-on containers. | *EventBridge Scheduler* (market-aware cron), *Step Functions Map state* for per-batch fan-out, *Lambda Powertools for AWS SDK* (concurrency limits), *DynamoDB TTL* or *S3* for caching API responses between invocations, *CloudWatch Anomaly Detection* alarms on the delta metrics. |
| LLM sentiment overrides / cleanup batches | Manual override jobs call `get_llm_sentiment_service()` and update rows in threaded batches when an operator wants to re-score everything with an LLM-only or dual-model strategy.【F:jobs/jobs/override_sentiment_with_llm.py†L1-L118】 | These jobs are CPU-bound but episodic; moving them to a Lambda function packaged as a container image lets you spin up dozens of parallel workers fed by SQS without extending the ECS fleet. Step Functions can break a “re-score 10k articles” request into shards and track failures without bespoke orchestration code. | *Lambda container images* (for `torch`/`transformers` size), *SQS + Lambda event source* (chunk queue), *Step Functions Distributed Map* (progress tracking), *Amazon Bedrock* as an LLM alternative when GPUs are unavailable, *Compute Optimizer* reports to confirm memory sizing. |
| Historical Reddit backfills | `jobs/jobs/scrape_monthly_discussions.py` crawls 30 days of daily threads via PRAW before inserting rows, which is expensive to keep idle on ECS but runs only during audits or migrations.【F:jobs/jobs/scrape_monthly_discussions.py†L1-L98】 | Lambda with EFS (to hold PRAW cache + Reddit linkers) can process a handful of days per invocation and push raw JSON to S3; ECS Fargate can then pull from S3 for heavy linking. This hybrid drastically reduces the time you need Spot capacity while keeping stateful work in a durable bucket. | *Lambda + EFS* (dependency layer >250 MB), *S3* for staging raw submissions, *Glue/Athena* to query archived JSON without restoring to Postgres, *EventBridge Pipes* to trigger linking tasks whenever new S3 objects land. |

## Future Enhancements That Benefit From Serverless Patterns
1. **Slack/Web push relays** – The `SlackService` already wraps rich job start/finish templates, so a lightweight Lambda exposed via API Gateway can accept webhook payloads from third-party monitors and reuse that service to alert internal channels without booting the full FastAPI stack.【F:app/services/slack_service.py†L1-L190】  Pair it with *Amazon SNS* or *AWS Chatbot* for multi-channel fan-out.
2. **User-facing notification triggers** – Watchlist changes and ticker follow events currently live in the relational DB; emitting `EventBridge` bus events from the FastAPI app (or via Aurora CDC) allows Lambda consumers to push mobile/web notifications, run personalization experiments, or hydrate feature flags without blocking HTTP requests.
3. **Stock anomaly detectors** – You already persist per-run metrics in `StockDataCollection`; streaming those inserts into *Amazon Timestream* or *CloudWatch Metrics* via Lambda lets you build anomaly alarms (e.g., zero successes for 5 minutes) without scraping container logs.
4. **LLM prompt caching service** – `DailySummaryService` builds prompts and calls LangChain before persisting results. A Lambda-backed API (behind API Gateway with IAM auth) could cache expensive prompts in DynamoDB with TTLs, so repeated Slack/email summaries during the same UTC day reuse the same token spend.

## Recommended Next Steps
1. **Decide on the packaging strategy** – Pure-Python jobs (Slack/email/delta calculators) can live in a single shared Lambda layer, while heavy ML or scraping functions should ship as Lambda container images to keep `torch` and `praw` available without re-downloading on every cold start.
2. **Extend Terraform** – Mirror the ECS modules with Lambda + EventBridge Scheduler modules so you can flip individual jobs between ECS and Lambda without changing application code. Include IAM policies for Secrets Manager access and VPC networking only where needed.
3. **Add observability guardrails** – Adopt Lambda Powertools for logging/metrics/tracing, and push job-level metrics (`success_count`, `failed_count`, `duration_seconds`) that the collectors already surface so you can compare ECS vs. Lambda cost/perf apples-to-apples before deleting task definitions.
4. **Document fallbacks** – Keep the ECS Makefile targets (e.g., `make ecs-run-status`) until the Lambda equivalents prove stable; your migration plan already warns that cron gaps occur after switching branches, so the rollback story should include `terraform destroy` for Lambda resources and a script to re-enable the ECS scheduler.
